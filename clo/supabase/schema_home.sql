-- ============================================
-- CLO HOME MANAGEMENT SCHEMA (HomeOS / CHO Dashboard)
-- The "Chief Household Officer" Module
-- ============================================

-- This file extends the base schema with Home management functionality
-- Run this AFTER the main schema.sql

-- Enable fuzzy search extension
create extension if not exists pg_trgm;

-- ============================================
-- 1. HOUSEHOLD PROFILE (Extends User Profile)
-- ============================================
alter table public.profiles 
add column if not exists household_name text, -- e.g. "The Miller Residence"
add column if not exists home_address jsonb default '{}'::jsonb, -- { street, city, state, zip }
add column if not exists home_photo_url text;

-- ============================================
-- 2. INVENTORY (The "Asset" Register)
-- Track all household items with warranty/manual info
-- ============================================
create table public.home_inventory (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references public.profiles(id) on delete cascade not null,
  product_name text not null,
  brand text,
  model_number text,
  serial_number text,
  purchase_date date,
  purchase_price numeric,
  warranty_months int, -- AI enriched
  warranty_expiration date,
  manual_url text, -- Link to PDF in Supabase Storage or external
  receipt_url text, -- Link to image in Supabase Storage
  product_image_url text,
  barcode text,
  category text, -- 'Kitchen', 'Garage', 'Living Room', 'HVAC', 'Appliances'
  location text, -- 'Master Bathroom', 'Garage'
  support_phone text, -- AI enriched
  maintenance_schedule text, -- AI enriched: "Change filter every 30 days"
  condition text default 'GOOD', -- 'NEW', 'GOOD', 'FAIR', 'NEEDS_REPAIR', 'REPLACED'
  notes text,
  created_at timestamp with time zone default now() not null,
  updated_at timestamp with time zone default now() not null
);

-- Enable RLS
alter table public.home_inventory enable row level security;

create policy "Users can manage their inventory"
  on public.home_inventory for all
  using (auth.uid() = user_id);

-- ============================================
-- 3. SUBSCRIPTIONS (Recurring Expenses)
-- The "Kill Switch" for money leaks
-- ============================================
create table public.subscriptions (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references public.profiles(id) on delete cascade not null,
  service_name text not null, -- Netflix, Gym, Lawn Care
  service_logo_url text,
  cost numeric not null,
  billing_cycle text not null, -- 'weekly', 'monthly', 'quarterly', 'yearly'
  next_billing_date date,
  last_billed_date date,
  payment_method text, -- 'Visa ending 4242'
  category text, -- 'Entertainment', 'Utilities', 'Health', 'SaaS'
  cancellation_method text, -- AI populates: "Call 555...", "Click here..."
  cancellation_instructions text, -- Detailed steps
  last_drafted_letter text, -- The actual email body generated by AI
  account_identifier text, -- Account number or email
  status text default 'ACTIVE', -- 'ACTIVE', 'PAUSED', 'CANCELLED', 'TRIAL'
  trial_ends_at date,
  importance text default 'OPTIONAL', -- 'ESSENTIAL', 'USEFUL', 'OPTIONAL', 'UNUSED'
  notes text,
  created_at timestamp with time zone default now() not null,
  updated_at timestamp with time zone default now() not null
);

-- Enable RLS
alter table public.subscriptions enable row level security;

create policy "Users can manage their subscriptions"
  on public.subscriptions for all
  using (auth.uid() = user_id);

-- ============================================
-- 4. VENDORS (The "Rolodex")
-- Contractors, service providers, handymen
-- ============================================
create table public.vendors (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references public.profiles(id) on delete cascade not null,
  company_name text not null,
  contact_person text,
  phone text,
  email text,
  website text,
  trade text not null, -- 'Plumber', 'Roofer', 'HVAC', 'Electrician', 'Landscaper'
  license_number text,
  insurance_verified boolean default false,
  rating int check (rating >= 1 and rating <= 5), -- 1-5 stars
  last_service_date date,
  total_spent numeric default 0, -- Calculated from service_logs
  is_preferred boolean default false, -- "Go-to" vendor for this trade
  notes text,
  created_at timestamp with time zone default now() not null,
  updated_at timestamp with time zone default now() not null
);

-- Enable RLS
alter table public.vendors enable row level security;

create policy "Users can manage their vendors"
  on public.vendors for all
  using (auth.uid() = user_id);

-- ============================================
-- 5. SERVICE LOGS (History of Work)
-- Track all repairs, maintenance, visits
-- ============================================
create table public.service_logs (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references public.profiles(id) on delete cascade not null,
  vendor_id uuid references public.vendors(id) on delete set null,
  inventory_id uuid references public.home_inventory(id) on delete set null, -- Optional link
  cost numeric,
  service_date date not null,
  description text not null,
  service_type text, -- 'REPAIR', 'MAINTENANCE', 'INSTALLATION', 'INSPECTION'
  receipt_url text,
  warranty_on_work_months int, -- Warranty for this specific service
  notes text,
  created_at timestamp with time zone default now() not null
);

-- Enable RLS
alter table public.service_logs enable row level security;

create policy "Users can manage their service logs"
  on public.service_logs for all
  using (auth.uid() = user_id);

-- ============================================
-- 6. MAINTENANCE SCHEDULES
-- Recurring maintenance reminders
-- ============================================
create table public.maintenance_schedules (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references public.profiles(id) on delete cascade not null,
  inventory_id uuid references public.home_inventory(id) on delete cascade,
  title text not null, -- "Change HVAC Filter"
  description text,
  frequency_days int not null, -- Every X days
  last_completed_at timestamp with time zone,
  next_due_at timestamp with time zone not null,
  is_active boolean default true,
  created_at timestamp with time zone default now() not null
);

-- Enable RLS
alter table public.maintenance_schedules enable row level security;

create policy "Users can manage their maintenance schedules"
  on public.maintenance_schedules for all
  using (auth.uid() = user_id);

-- ============================================
-- 7. HOME DOCUMENTS
-- Store important home documents (deeds, insurance, etc.)
-- ============================================
create table public.home_documents (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references public.profiles(id) on delete cascade not null,
  document_type text not null, -- 'DEED', 'INSURANCE', 'MORTGAGE', 'HOA', 'TAX', 'WARRANTY', 'OTHER'
  title text not null,
  description text,
  file_url text not null,
  file_size_bytes int,
  expiration_date date, -- For insurance policies, etc.
  renewal_reminder_days int default 30,
  created_at timestamp with time zone default now() not null
);

-- Enable RLS
alter table public.home_documents enable row level security;

create policy "Users can manage their home documents"
  on public.home_documents for all
  using (auth.uid() = user_id);

-- ============================================
-- 8. INDEXES FOR PERFORMANCE
-- ============================================
create index home_inventory_user_idx on public.home_inventory(user_id);
create index home_inventory_category_idx on public.home_inventory(category);
create index home_inventory_barcode_idx on public.home_inventory(barcode);
create index subscriptions_user_idx on public.subscriptions(user_id);
create index subscriptions_next_billing_idx on public.subscriptions(next_billing_date);
create index subscriptions_status_idx on public.subscriptions(status);
create index vendors_user_idx on public.vendors(user_id);
create index vendors_trade_idx on public.vendors(trade);
create index service_logs_user_idx on public.service_logs(user_id);
create index service_logs_vendor_idx on public.service_logs(vendor_id);
create index service_logs_date_idx on public.service_logs(service_date desc);
create index maintenance_next_due_idx on public.maintenance_schedules(next_due_at);

-- Trigram indexes for fuzzy search
create index vendors_name_trgm_idx on public.vendors using gin (company_name gin_trgm_ops);
create index vendors_trade_trgm_idx on public.vendors using gin (trade gin_trgm_ops);
create index service_logs_desc_trgm_idx on public.service_logs using gin (description gin_trgm_ops);

-- ============================================
-- 9. TRIGGERS
-- ============================================
create trigger update_home_inventory_updated_at 
  before update on public.home_inventory
  for each row execute procedure update_updated_at_column();

create trigger update_subscriptions_updated_at 
  before update on public.subscriptions
  for each row execute procedure update_updated_at_column();

create trigger update_vendors_updated_at 
  before update on public.vendors
  for each row execute procedure update_updated_at_column();

-- Update vendor total_spent when service_log is added
create or replace function update_vendor_total_spent()
returns trigger as $$
begin
  if new.vendor_id is not null then
    update public.vendors
    set 
      total_spent = (
        select coalesce(sum(cost), 0) 
        from public.service_logs 
        where vendor_id = new.vendor_id
      ),
      last_service_date = new.service_date
    where id = new.vendor_id;
  end if;
  return new;
end;
$$ language plpgsql;

create trigger update_vendor_totals
  after insert on public.service_logs
  for each row execute procedure update_vendor_total_spent();

-- ============================================
-- 10. SEARCH FUNCTION (The "Vendor Memory")
-- Fuzzy search across vendors AND service history
-- ============================================
create or replace function search_vendors(search_term text, user_id_param uuid)
returns table (
  vendor_id uuid,
  company_name text,
  trade text,
  phone text,
  last_service_date date,
  total_spent numeric,
  match_reason text
) 
language plpgsql
as $$
begin
  return query
  select distinct
    v.id,
    v.company_name,
    v.trade,
    v.phone,
    v.last_service_date,
    v.total_spent,
    case
      when v.company_name ilike '%' || search_term || '%' then 'Matched Name'
      when v.trade ilike '%' || search_term || '%' then 'Matched Trade'
      else 'Matched History: ' || (
        select left(description, 50) || '...' 
        from service_logs s 
        where s.vendor_id = v.id 
        and s.description ilike '%' || search_term || '%' 
        limit 1
      )
    end as match_reason
  from
    vendors v
  left join
    service_logs s on v.id = s.vendor_id
  where
    v.user_id = user_id_param
    and (
      v.company_name ilike '%' || search_term || '%'
      or v.trade ilike '%' || search_term || '%'
      or s.description ilike '%' || search_term || '%'
    )
  order by v.last_service_date desc nulls last;
end;
$$;

-- ============================================
-- 11. DASHBOARD FUNCTIONS
-- ============================================

-- Get upcoming alerts (warranties, bills, maintenance)
create or replace function get_home_alerts(user_id_param uuid)
returns jsonb as $$
declare
  result jsonb;
begin
  select jsonb_build_object(
    'expiring_warranties', (
      select jsonb_agg(jsonb_build_object(
        'id', id,
        'product_name', product_name,
        'warranty_expiration', warranty_expiration,
        'days_remaining', warranty_expiration - current_date
      ))
      from public.home_inventory
      where user_id = user_id_param
      and warranty_expiration is not null
      and warranty_expiration between current_date and current_date + 30
    ),
    'upcoming_bills', (
      select jsonb_agg(jsonb_build_object(
        'id', id,
        'service_name', service_name,
        'cost', cost,
        'next_billing_date', next_billing_date
      ))
      from public.subscriptions
      where user_id = user_id_param
      and status = 'ACTIVE'
      and next_billing_date between current_date and current_date + 7
    ),
    'overdue_maintenance', (
      select jsonb_agg(jsonb_build_object(
        'id', id,
        'title', title,
        'next_due_at', next_due_at,
        'days_overdue', current_date - next_due_at::date
      ))
      from public.maintenance_schedules
      where user_id = user_id_param
      and is_active = true
      and next_due_at < now()
    ),
    'monthly_subscription_cost', (
      select coalesce(sum(
        case billing_cycle
          when 'weekly' then cost * 4
          when 'monthly' then cost
          when 'quarterly' then cost / 3
          when 'yearly' then cost / 12
          else cost
        end
      ), 0)
      from public.subscriptions
      where user_id = user_id_param
      and status = 'ACTIVE'
    )
  ) into result;
  
  return result;
end;
$$ language plpgsql security definer;
